<!DOCTYPE html>
<html>
<head>
    <title>QTiled Demo</title>
    <meta charset="utf-8">
    <meta name="description" content="Vision Player Demo">
    <meta name="viewport" content="width=device-width, user-scalable=yes, initial-scale=1, maximum-scale=1">
    <meta name="mobile-web-app-capable" content="yes">
    <link rel="stylesheet" type="text/css" href="./static/css/reset.css">
    <style type="text/css">
      body {
        max-width: none;
        text-align: center;
      }

      #container {
        margin: 10px auto;
        width: 820px;
        height: 620px;
        background: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
      }
    </style>

</head>
<body>

  <header>
      <h1>QTiled Demo</h1>
  </header>
  <section id="container">
      <!-- my canvas -->
  </section>

  <script src="https://unpkg.com/spritejs@3/dist/spritejs.js"></script>
  <script src="./static/js/qtiled.dev.js"></script>
  <script>
    const { Scene, Sprite, Group, Label } = spritejs;
    const scene = new Scene({
      container: document.getElementById('container'),
      width: 800,
      height: 600,
      mode: 'static', // scale
    });
    const fglayer = scene.layer('fglayer');
    const ctlayer = scene.layer('ctlayer');


    class Grid extends Sprite {

      constructor (attr = {
        border: [1,'rgba(0, 0, 0, .4)'],
        size: [],
      }) {

        super();

        const {size, id, border, pos} = attr;
        const [w = 1, h = 1] = size;
        const {scaleX, scaleY, gridWH} = calculate(w, h, border[0]);
        super.attr(Object.assign(attr, {
          anchor: [0.5, 0.5],
          size: [gridWH, gridWH],
          scale: [scaleX, scaleY],
          rotate: 45,
        }));
        if(typeof(id)==='function'){
          attr.id = id.bind(this)();
        }
      }
      /*dispatchEvent(...args){
        console.log('dispatch')
        return super.dispatchEvent(...args)
      }*/

    };

    const _cache = {};
    function calculate (w = 1, h = 1, bw = 0) {
      const _cache_key = w + ',' + h + ',' + bw;
      if(_cache[_cache_key])return _cache[_cache_key];

      const whv = (w + h) / 2;
      const diagonal = Math.sqrt(Math.pow(whv, 2) * 2);

      return (_cache[_cache_key] = {
        scaleX: w / diagonal,
        scaleY: h / diagonal,
        gridWH: whv - bw * 2
      });
    }

        
    const _labels = Symbol('_labels');
    const _grids_map = Symbol('_grids_map');
    class GridsGroup extends Group {

      /* grids 参数示例：
        {
          borderWidth: 1,
          borderColor: 'rgba(0, 0, 0, .4)',
          bgColor: 'rgba(255, 0, 0, 0)',
          size: [],
          poss:[ [x,y], [x1,y1] ],
          id
        }
      */
      constructor (opts = {}) {
        const gridsConf = opts.grids;
        const {poss = [], size = [0, 0], offset=[0, 0], ids=[]} = gridsConf;
        delete opts.grids;
        delete gridsConf.poss;
        delete gridsConf.offset;
        delete gridsConf.ids;

        super(opts);


        this[_grids_map]={}
        this[_labels]=[]

        let minX = 0;
        let minY = 0;
        const gridsPoss = poss.map(([x, y])=>{
          if(x < minX) minX = x;
          if(y < minY) minY = y;
          return [x, y];
        });

        const [w, h] = size;

        const centerX = -minX+w/2+ offset[0];
        const centerY = -minY+h/2+ offset[1];

        const gridSprites = gridsPoss.map(([x, y], i)=>{
          const pos = [x + centerX, y + centerY];
          const idx = ids[i];
          const grid = new Grid(
            Object.assign({},
              gridsConf,
              { pos }
            )
          );
          grid._grid_id = idx;
          this[_grids_map][idx.join()] = grid;

          const label = new Label( (idx||pos).join())
          this[_labels].push(label);
          label._grid_id = idx;
          label.attr({
            anchor: [0.5, 0.5],
            pos,
            padding: 2,
            font: 'italic 12px Arial',
            fillColor: opts.color||'#00000080',
            // opacity:0
          });
          return grid;
        });

        this.append(...gridSprites.concat(this[_labels]));
      }
      getGridRealPosByIdx(idx){
        const grid = this.getGridByIdx(idx);
        if(!grid) return;
        const [gridPxX, gridPxY] = grid.attr('pos');
        const groupLeft = this.renderMatrix[4];
        const groupTop = this.renderMatrix[5];
        // 中心单元格渲染到Canvas上后的真实像素坐标（自身pos+group.pos）
        return [groupLeft+gridPxX, groupTop+gridPxY];
      }
      getGridByIdx(idx){
        return this[_grids_map][idx]
      }
      get labels(){
        return this[_labels];
      }
      showIds(opts={}){
        this[_labels].forEach(lb=>{
          lb.attr( Object.assign({'opacity':1},opts));
        });
        //this.forceUpdate(true)
      }
      hideIds(){
        this[_labels].forEach(lb=>{
          lb.attr('opacity',0);
        });
        //this.forceUpdate(true)
      }
    };


  </script>
  <script>
        
    // 横纵向菱形网格数量
    const rowCount = 11;
    const colCount = 10;

    const sceneSize = [scene.width, scene.height];
    const centerPixel = sceneSize.map((v) => v / 2);
    const tileSize = [78,40];

    const data = qtiled.getStaggeredUnitsByRowCol(rowCount, colCount);

    const tilePx2Ids = {};
    const tilePixels = data.map((ids)=>{
      const px = qtiled.unit2rhombusPixel(ids, tileSize);
      tilePx2Ids[px.join()] = ids;
      return px;
    });
    const g = new spritejs.Group({
        anchor: [0.5, 0.5],
        pos: centerPixel,
        border: [2, '#ff0'],
      });
    g.append(
      new spritejs.Block({
        anchor: [0.5, 0.5],
        pos: [0, 0],
        size: [100, 100],
        border: [2, '#000'],
      })
    );
    fglayer.append(
      g
    );

    window.gridsGroup = new GridsGroup({
      bgcolor:'rgba(0, 255, 255, 0.05)',
      anchor: [0, 0],
      pos: [0, 0],
      size: sceneSize,
      grids: {
        size: tileSize,
        ids:data,
        poss: tilePixels,
        border: [1, 'rgba(0,0,0,0.2)']
      }
    });

    fglayer.append(gridsGroup); 

    const gridsGroupPos = gridsGroup.attr('pos');


    // 交互

    function getGridsGroup(xN, yN, pos = [0, 0]){
      
      const xyIds = [];
      const poss = qtiled.getUnitsByRowCol(xN, yN, (x,y)=>{
        const xyId = [x, y];
        xyIds.push(xyId);
        return qtiled.unit2rhombusPixel(xyId, tileSize)
      });
      
      return new GridsGroup({
        name:'focus',
        anchor: [0, 0],
        //border: [1, 'rgba(255,0,0,1)'],
        // bgcolor:'#ff000020',
        pos,
        grids: {
          ids:xyIds,
          size: tileSize,
          poss,
          border: [1, 'rgba(255,100,100,1)'],
          bgcolor:'#ffffff80'
        },
        color:'#ff000080',
      });
    } 

    // 地图原点坐标
    const goRenderPos = gridsGroup.getGridRealPosByIdx('0,0')||[0,0];


    // 生成交互的焦点格子
    const focusGrids = window.focusGrids = getGridsGroup(1, 1, centerPixel);

    // 操作格子原点坐标
    const foRenderPos = focusGrids.getGridRealPosByIdx('0,0');

    // 操作原点与地图原点的差值
    let fgRenderPos = [goRenderPos[0]-foRenderPos[0], goRenderPos[1]-foRenderPos[1]];

    setFocusPos(focusGrids.attr('pos'));


    function setFocusPos(pxArr){
      focusGrids.attr('pos',pxArr.map((v,i)=>v+fgRenderPos[i] ));
    } 

    ctlayer.append(focusGrids);


    const sceneSxs = [1, 1];//scene.resolution.map((v,i)=>v/scene.viewport[i]);

    let _hisRPX = null;
    document.addEventListener('mousemove',e=>{

      const roundPx = qtiled.staggeredUnitRound(
        [e.pageX * sceneSxs[0], e.pageY * sceneSxs[1]], 
        tileSize,
      );
      const hisRPX = roundPx.join();
      if(_hisRPX===hisRPX)return;
      _hisRPX = hisRPX;
      
      
      let focusGridId = tilePx2Ids[roundPx.map((v,i)=>v-gridsGroupPos[i]).join()];
      focusGridId=focusGridId||[0,0];
      
      focusGridId && focusGrids.labels.forEach(lb=>{
        lb.text = lb._grid_id.map((v,i)=>v+focusGridId[i]).join()
      });

      
      setFocusPos( roundPx );
      
    })
  </script>
</body>
</html>